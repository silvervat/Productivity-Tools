import { useRef, useState, useCallback } from "react";
import * as WorkspaceAPI from "trimble-connect-workspace-api";
import "./AdvancedMarkupBuilder.css";

type Language = "et" | "en";
interface MarkupResult {
  text: string;
  count: number;
}
interface PropertyField {
  name: string;
  value: string;
  selected: boolean;
}
const translations = {
  et: {
    title: "MARKUP KOOSTE EHITAJA",
    discoverFields: "üîç TUVASTA ANDMEV√ÑLJAD",
    selectedFields: "Valitud v√§ljad (lohisemiseks):",
    noFieldsSelected: "‚ùå Palun vali v√§hemalt √ºks v√§li!",
    separator: "Eraldaja:",
    prefix: "Eesliide:",
    useLineBreak: "Kasuta reavahte (√ºhekaupa alla)",
    applyMarkup: "‚ûï LISA MARKUP",
    condenseResults: "üìã KOONDA & KOPEERI",
    results: "Tulemused:",
    selectObjects: "‚ö†Ô∏è Palun vali objektid 3D vaates",
    discovering: "Tuvastan v√§ljasid...",
    applying: "Lisastan markup...",
    success: "‚úÖ Markup lisatud",
    noDataDiscovered: "‚ö†Ô∏è Objektidel puuduvad omadused",
    error: "‚ùå Viga:",
    dragHint: "Lohista v√§ljad soovitud j√§rjekorda",
  },
  en: {
    title: "ADVANCED MARKUP BUILDER",
    discoverFields: "üîç DISCOVER FIELDS",
    selectedFields: "Selected fields (drag to reorder):",
    noFieldsSelected: "‚ùå Please select at least one field!",
    separator: "Separator:",
    prefix: "Prefix:",
    useLineBreak: "Use line breaks (one per line)",
    applyMarkup: "‚ûï ADD MARKUP",
    condenseResults: "üìã CONDENSE & COPY",
    results: "Results:",
    selectObjects: "‚ö†Ô∏è Please select objects in 3D view",
    discovering: "Discovering fields...",
    applying: "Applying markup...",
    success: "‚úÖ Markup applied",
    noDataDiscovered: "‚ö†Ô∏è Objects have no properties",
    error: "‚ùå Error:",
    dragHint: "Drag fields to reorder",
  },
};
const SEPARATORS = [
  { label: " | ", value: " | " },
  { label: " - ", value: " - " },
  { label: " , ", value: " , " },
  { label: " . ", value: " . " },
  { label: " : ", value: " : " },
  { label: " / ", value: " / " },
  { label: "\\n (new line)", value: "\n" },
];
interface AdvancedMarkupBuilderProps {
  api: WorkspaceAPI.WorkspaceAPI | undefined;
  language?: Language;
}

// Assembly Exporterist p√§rit abifunktsioonid (t√§ielikult integreeritud)
function sanitizeKey(s: string) {
  return String(s).replace(/\s+/g, "_").replace(/[^\w.-]/g, "").replace(/\+/g, ".").trim();
}
function normalizeGuid(s: string): string {
  return s.replace(/^urn:(uuid:)?/i, "").trim();
}
function classifyGuid(val: string): "IFC" | "MS" | "UNKNOWN" {
  const s = normalizeGuid(val.trim());
  if (/^[0-9A-Za-z_$]{22}$/.test(s)) return "IFC";
  if (/^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/.test(s) || /^[0-9A-Fa-f]{32}$/.test(s)) return "MS";
  return "UNKNOWN";
}
async function getPresentationLayerString(api: any, modelId: string, runtimeId: number): Promise<string> {
  try {
    const layers = (await api?.viewer?.getObjectLayers?.(modelId, [runtimeId])) ?? (await api?.viewer?.getPresentationLayers?.(modelId, [runtimeId]));
    if (Array.isArray(layers) && layers.length) {
      const first = Array.isArray(layers[0]) ? layers[0] : layers;
      return first.filter(Boolean).map(String).join(", ");
    }
  } catch {}
  return "";
}
async function getReferenceObjectInfo(
  api: any,
  modelId: string,
  runtimeId: number
): Promise<{ fileName?: string; fileFormat?: string; commonType?: string; guidIfc?: string; guidMs?: string }> {
  const out: any = {};
  try {
    const meta = (await api?.viewer?.getObjectMetadata?.(modelId, [runtimeId])) ?? (await api?.viewer?.getObjectInfo?.(modelId, runtimeId));
    const m = Array.isArray(meta) ? meta[0] : meta;
    if (m?.file?.name) out.fileName = String(m.file.name);
    if (m?.file?.format) out.fileFormat = String(m.file.format);
    if (m?.commonType) out.commonType = String(m.commonType);
    if (m?.globalId) out.guidMs = String(m.globalId);
    if (!out.guidIfc) {
      try {
        const ext = await api?.viewer?.convertToObjectIds?.(modelId, [runtimeId]);
        if (ext && ext[0]) out.guidIfc = String(ext[0]);
      } catch {}
    }
  } catch {}
  return out;
}
async function getProjectName(api: any): Promise<string> {
  try {
    const proj = typeof api?.project?.getProject === "function" ? await api.project.getProject() : api?.project || {};
    return String(proj?.name || "");
  } catch {
    return "";
  }
}
async function buildModelNameMap(api: any, modelIds: string[]) {
  const map = new Map<string, string>();
  try {
    const list: any[] = await api?.viewer?.getModels?.();
    for (const m of list || []) {
      if (m?.id && m?.name) map.set(String(m.id), String(m.name));
    }
  } catch {}
  for (const id of new Set(modelIds)) {
    if (map.has(id)) continue;
    try {
      const f = await api?.viewer?.getLoadedModel?.(id);
      const n = f?.name || f?.file?.name;
      if (n) map.set(id, String(n));
    } catch {}
  }
  return map;
}
async function getSelectedObjects(api: any): Promise<Array<{ modelId: string; objects: any[] }>> {
  const viewer: any = api?.viewer;
  const mos = await viewer?.getObjects?.({ selected: true });
  if (!Array.isArray(mos) || !mos.length) return [];
  return mos.map((mo: any) => ({ modelId: String(mo.modelId), objects: mo.objects || [] }));
}

// PARANDATUD: flattenProps otse Assembly Exporterist (t√§ielik, async)
async function flattenProps(
  obj: any,
  modelId: string,
  projectName: string,
  modelNameById: Map<string, string>,
  api: any
): Promise<Record<string, string>> {
  const out: Record<string, string> = {
    GUID: "",
    GUID_IFC: "",
    GUID_MS: "",
    Project: String(projectName || ""),
    ModelId: String(modelId),
    FileName: modelNameById.get(modelId) || "",
    Name: "",
    Type: "Unknown",
  };
  const propMap = new Map<string, string>();
  const keyCounts = new Map<string, number>();
  const push = (group: string, name: string, val: unknown) => {
    const g = sanitizeKey(group);
    const n = sanitizeKey(name);
    const baseKey = g ? `${g}.${n}` : n;
    let key = baseKey;
    const count = keyCounts.get(baseKey) || 0;
    if (count > 0) key = `${baseKey}_${count}`;
    keyCounts.set(baseKey, count + 1);
    let v: unknown = val;
    if (Array.isArray(v)) v = v.map(x => (x == null ? "" : String(x))).join(" | ");
    else if (typeof v === "object" && v !== null) v = JSON.stringify(v);
    const s = v == null ? "" : String(v);
    propMap.set(key, s);
    out[key] = s;
  };
  // Property setid (sh peidetud)
  if (Array.isArray(obj?.properties)) {
    obj.properties.forEach((propSet: any) => {
      const setName = propSet?.name || "Unknown";
      const setProps = propSet?.properties || [];
      if (Array.isArray(setProps)) {
        setProps.forEach((prop: any) => {
          const value = prop?.displayValue ?? prop?.value;
          const name = prop?.name || "Unknown";
          push(setName, name, value);
        });
      }
    });
  } else if (typeof obj?.properties === "object" && obj.properties !== null && !Array.isArray(obj.properties)) {
    Object.entries(obj.properties).forEach(([key, val]) => {
      if (val !== null && val !== undefined) {
        push("Properties", key, val);
      }
    });
  }
  // Standard v√§ljad
  if (obj?.id) out.ObjectId = String(obj.id);
  if (obj?.name) out.Name = String(obj.name);
  if (obj?.type) out.Type = String(obj.type);
  if (obj?.product?.name) out.ProductName = String(obj.product.name);
  if (obj?.product?.description) out.ProductDescription = String(obj.product.description);
  if (obj?.product?.type) out.ProductType = String(obj.product.type);
  // UUS: Fallback Product v√§ljadele property-set'idest
  if (!out.ProductName || !out.ProductDescription || !out.ProductType) {
    const props: any[] = Array.isArray(obj?.properties) ? obj.properties : [];
    for (const set of props) {
      for (const p of set?.properties ?? []) {
        if (/product[_\s]?name/i.test(p?.name) && !out.ProductName) out.ProductName = String(p?.value || p?.displayValue || "");
        if (/product[_\s]?description/i.test(p?.name) && !out.ProductDescription) out.ProductDescription = String(p?.value || p?.displayValue || "");
        if (/product[_\s]?object[_\s]?type/i.test(p?.name) && !out.ProductType) out.ProductType = String(p?.value || p?.displayValue || "");
      }
    }
    console.log(`flattenProps: Lisasin Product fallback'id: Name=${out.ProductName}, Desc=${out.ProductDescription}, Type=${out.ProductType}`);
  }
  // GUIDid propidest
  let guidIfc = "";
  let guidMs = "";
  for (const [k, v] of propMap) {
    if (!/guid|globalid|tekla_guid|id_guid/i.test(k)) continue;
    const cls = classifyGuid(v);
    if (cls === "IFC" && !guidIfc) guidIfc = v;
    if (cls === "MS" && !guidMs) guidMs = v;
  }
  // UUS: Spetsiifiline k√§sitlemine ReferenceObject+GUID (MS)
  if (guidMs) {
    const jsonKey = "ReferenceObject.GUID_MS";
    out[jsonKey] = guidMs;
    console.log(`flattenProps: Leidsin ReferenceObject+GUID (MS): ${guidMs}`);
  }
  // Lisa metadata.globalId GUID_MS jaoks
  try {
    console.log(`flattenProps: Proovin lugeda metadata modelId=${modelId}, objId=${obj?.id}`);
    const metaArr = await api?.viewer?.getObjectMetadata?.(modelId, [obj?.id]);
    const metaOne = Array.isArray(metaArr) ? metaArr[0] : metaArr;
    console.log(`flattenProps: Metadata tulemus: ${JSON.stringify(metaOne)}`);
    if (metaOne?.globalId) {
      const g = String(metaOne.globalId);
      out.GUID_MS = out.GUID_MS || g;
      out["ReferenceObject.GlobalId"] = g;
      console.log(`flattenProps: Leidsin GUID_MS: ${g}`);
    } else {
      console.log("flattenProps: globalId puudub metadata's");
    }
  } catch (e) {
    console.log("flattenProps: getObjectMetadata viga: " + e.message);
  }
  // IFC GUID fallback (runtime->external)
  if (!guidIfc && obj.id) {
    try {
      const externalIds = await api.viewer.convertToObjectIds(modelId, [obj.id]);
      const externalId = externalIds[0];
      if (externalId && classifyGuid(externalId) === "IFC") guidIfc = externalId;
      console.log(`flattenProps: Leidsin GUID_IFC fallback'ist: ${guidIfc}`);
    } catch (e) {
      console.log(`flattenProps: convertToObjectIds viga objId=${obj.id}: ${e.message}`);
    }
  }
  // Presentation Layers fallback
  if (![...propMap.keys()].some(k => k.toLowerCase().startsWith("presentation_layers."))) {
    const rid = Number(obj?.id);
    if (Number.isFinite(rid)) {
      const layerStr = await getPresentationLayerString(api, modelId, rid);
      if (layerStr) {
        const key = "Presentation_Layers.Layer";
        propMap.set(key, layerStr);
        out[key] = layerStr;
        console.log(`flattenProps: Leidsin Presentation Layers: ${layerStr}`);
      }
    }
  }
  // Reference Object fallback
  const hasRefBlock = [...propMap.keys()].some(k => k.toLowerCase().startsWith("referenceobject."));
  if (!hasRefBlock) {
    const rid = Number(obj?.id);
    if (Number.isFinite(rid)) {
      const ref = await getReferenceObjectInfo(api, modelId, rid);
      if (ref.fileName) out["ReferenceObject.File_Name"] = ref.fileName;
      if (ref.fileFormat) out["ReferenceObject.File_Format"] = ref.fileFormat;
      if (ref.commonType) out["ReferenceObject.Common_Type"] = ref.commonType;
      if (!guidIfc && ref.guidIfc) guidIfc = ref.guidIfc;
      if (!guidMs && ref.guidMs) guidMs = ref.guidMs;
      console.log(`flattenProps: Reference Object info: ${JSON.stringify(ref)}`);
    }
  }
  out.GUID_IFC = guidIfc;
  out.GUID_MS = guidMs;
  out.GUID = guidIfc || guidMs || "";
  return out;
}

export default function AdvancedMarkupBuilder({
  api,
  language = "et",
}: AdvancedMarkupBuilderProps) {
  const t = translations[language];
  const [discoveredFields, setDiscoveredFields] = useState<{ [key: string]: PropertyField }>({});
  const [orderedFields, setOrderedFields] = useState<string[]>([]);
  const [isDiscovering, setIsDiscovering] = useState(false);
  const [isApplying, setIsApplying] = useState(false);
  const [discoveryError, setDiscoveryError] = useState("");
  const [markupPrefix, setMarkupPrefix] = useState("");
  const [markupSeparator, setMarkupSeparator] = useState(" | ");
  const [useLineBreak, setUseLineBreak] = useState(false);
  const [markupResults, setMarkupResults] = useState<MarkupResult[]>([]);
  const [successMessage, setSuccessMessage] = useState("");
  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);
  const previousMarkupIds = useRef<string[]>([]);

  // Lohistamise handlers (sama kui varem)
  const handleDragStart = useCallback((e: React.DragEvent<HTMLDivElement>, index: number) => {
    setDraggedIndex(index);
    e.dataTransfer.effectAllowed = "move";
  }, []);
  const handleDragOver = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  }, []);
  const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>, dropIndex: number) => {
    e.preventDefault();
    if (draggedIndex === null || draggedIndex === dropIndex) return;
    const newOrder = [...orderedFields];
    const [draggedItem] = newOrder.splice(draggedIndex, 1);
    newOrder.splice(dropIndex, 0, draggedItem);
    setOrderedFields(newOrder);
    setDraggedIndex(null);
  }, [draggedIndex, orderedFields]);

  // PARANDATUD: discoverFields ‚Äì n√º√ºd nagu Assembly Exporteri discover(), t√∂√∂tleb K√ïIKI objekte ja kogub unikaalsed v√§ljad
  const discoverFields = useCallback(async () => {
    if (!api?.viewer) {
      setDiscoveryError(t.selectObjects);
      return;
    }
    setIsDiscovering(true);
    setDiscoveryError("");
    try {
      // Assembly Exporteri stiilis: saa valitud objektid
      const selectedWithBasic = await getSelectedObjects(api);
      if (!selectedWithBasic.length) {
        setDiscoveryError(t.selectObjects);
        setIsDiscovering(false);
        return;
      }
      const projectName = await getProjectName(api);
      const modelIds = selectedWithBasic.map(m => m.modelId);
      const nameMap = await buildModelNameMap(api, modelIds);
      const allFlattened: Record<string, string>[] = []; // Kogu k√µik lamendatud objektid
      let totalObjs = selectedWithBasic.reduce((sum, m) => sum + (m.objects?.length || 0), 0);
      console.log(`Discover: T√∂√∂tan ${selectedWithBasic.length} mudelit, kokku ${totalObjs} objekti`);
      let processedObjects = 0;
      for (let i = 0; i < selectedWithBasic.length; i++) {
        const { modelId, objects } = selectedWithBasic[i];
        const objectRuntimeIds = objects.map((o: any) => Number(o?.id)).filter((n: number) => Number.isFinite(n));
        let fullObjects = objects;
        try {
          const fullProperties = await api.viewer.getObjectProperties(modelId, objectRuntimeIds, { includeHidden: true });
          fullObjects = objects.map((obj: any, idx: number) => ({
            ...obj,
            properties: fullProperties[idx]?.properties || obj.properties,
          }));
          console.log(`Discover: Laadisin ${fullProperties.length} omadust mudelisse ${modelId}`);
        } catch (e) {
          console.warn(`getObjectProperties failed for model ${modelId}: ${e.message}`);
        }
        const flattened = await Promise.all(fullObjects.map((o: any) => flattenProps(o, modelId, projectName, nameMap, api)));
        allFlattened.push(...flattened);
        processedObjects += objects.length;
        console.log(`Discover: T√∂√∂deldud ${processedObjects}/${totalObjs} objekti`);
      }
      // Kogu unikaalsed v√§ljad K√ïIGIST objektidest (nagu Exporteris)
      const allKeys = Array.from(new Set(allFlattened.flatMap(r => Object.keys(r)))).filter(k => k !== "ObjectId" && k !== "Project" && k !== "ModelId" && k !== "FileName"); // V√§ltige sisemisi
      console.log(`Discover: Leitud unikaalseid v√µtmeid: ${allKeys.length}, esimesed: ${allKeys.slice(0, 10).join(", ")}`);
      const fieldsMap: { [key: string]: PropertyField } = {};
      let fieldCount = 0;
      for (const key of allKeys.slice(0, 20)) { // Piira 20-ni, et UI ei l√§heks segamini
        // V√µta n√§ide v√§√§rtusest esimesest objektist, kus see on
        const sampleValue = allFlattened.find(r => r[key] && r[key].trim().length > 0)?.[key] || `(${key})`;
        if (sampleValue && sampleValue.trim().length > 0) {
          fieldsMap[key] = {
            name: key,
            value: String(sampleValue).substring(0, 100),
            selected: fieldCount < 5, // Vaikimisi esimesed 5 valitud
          };
          fieldCount++;
        }
      }
      if (fieldCount === 0) {
        const defaultFields = ['Name', 'Type', 'GUID', 'Code', 'Description'];
        defaultFields.forEach((field) => {
          fieldsMap[field] = { name: field, value: `(${field})`, selected: fieldCount < 3 };
          fieldCount++;
        });
      }
      setDiscoveredFields(fieldsMap);
      setOrderedFields(Object.keys(fieldsMap).filter(key => fieldsMap[key].selected));
      setSuccessMessage(`‚úÖ ${fieldCount} v√§lja leitud ${allFlattened.length} objektist!`);
      setTimeout(() => setSuccessMessage(""), 3000);
    } catch (err: any) {
      setDiscoveryError(`${t.error} ${err.message}`);
      console.error("Discover error:", err);
    } finally {
      setIsDiscovering(false);
    }
  }, [api, t]);

  const toggleFieldSelection = (fieldName: string) => {
    setDiscoveredFields((prev) => {
      const newMap = { ...prev, [fieldName]: { ...prev[fieldName], selected: !prev[fieldName].selected } };
      const newOrder = Object.keys(newMap).filter(key => newMap[key].selected);
      setOrderedFields(newOrder);
      return newMap;
    });
  };

  // applyMarkup ‚Äì uuendatud, kasutab flattenProps k√µigi jaoks (sama loogika)
  const applyMarkup = useCallback(async () => {
    if (!api?.viewer || orderedFields.length === 0) { setDiscoveryError(t.noFieldsSelected); return; }
    setIsApplying(true); setDiscoveryError(""); setSuccessMessage("");
    try {
      const selection = await api.viewer.getSelection();
      if (!selection || selection.length === 0) { setDiscoveryError(t.selectObjects); setIsApplying(false); return; }
      const results: MarkupResult[] = [];
      const newMarkupIds: string[] = [];
      const projectName = await getProjectName(api);
      const modelIds = selection.map((item: any) => item.modelId).filter(Boolean);
      const nameMap = await buildModelNameMap(api, modelIds);
      for (const selectionItem of selection) {
        if (!selectionItem.objectRuntimeIds) continue;
        const objectRuntimeIds = selectionItem.objectRuntimeIds.map((id: any) => typeof id === 'string' ? parseInt(id) : id).filter((n: number) => Number.isFinite(n));
        if (objectRuntimeIds.length === 0) continue;
        const fullProperties = await (api.viewer as any).getObjectProperties?.(selectionItem as any, objectRuntimeIds, { includeHidden: true });
        if (!fullProperties) continue;
        for (let idx = 0; idx < objectRuntimeIds.length; idx++) {
          const props = Array.isArray(fullProperties) ? fullProperties[idx] : fullProperties;
          if (!props?.properties) continue;
          const flattened = await flattenProps(props, selectionItem.modelId || "", projectName, nameMap, api);
          const values = orderedFields.map((fieldName) => flattened[fieldName] || "").filter((v) => v.length > 0);
          if (values.length === 0) continue;
          const separator = useLineBreak ? "\n" : markupSeparator;
          const markupText = markupPrefix + values.join(separator);
          try {
            const markupId = await (api.markup as any).add({ label: markupText, objectId: objectRuntimeIds[idx] });
            if (markupId) { newMarkupIds.push(markupId); results.push({ text: markupText, count: 1 }); }
          } catch { continue; }
        }
      }
      previousMarkupIds.current = newMarkupIds;
      setMarkupResults(results);
      if (results.length > 0) { setSuccessMessage(`‚úÖ Markup lisatud ${results.length} objektile!`); } else { setDiscoveryError(t.noDataDiscovered); }
    } catch (err: any) {
      setDiscoveryError(`${t.error} ${err.message}`);
      console.error("Apply markup error:", err);
    } finally { setIsApplying(false); }
  }, [api, orderedFields, useLineBreak, markupSeparator, markupPrefix, t]);

  const condenseAndCopy = useCallback(() => {
    if (markupResults.length === 0) { setDiscoveryError("Tulemusi pole"); return; }
    const condensed = markupResults.reduce((acc, result) => { const existing = acc.find((r) => r.text === result.text); if (existing) { existing.count++; } else { acc.push({ ...result }); } return acc; }, [] as MarkupResult[]);
    const text = condensed.map((r) => `${r.text} - ${r.count}tk`).join("\n");
    navigator.clipboard.writeText(text).then(() => { setSuccessMessage("‚úÖ Kopeeritud l√µikelauale!"); setTimeout(() => setSuccessMessage(""), 3000); });
  }, [markupResults]);

  const selectedCount = orderedFields.length;

  // Render (sama kui varem, lohistamisega)
  return (
    <div className="amb-container">
      <div className="amb-header"><h2>{t.title}</h2></div>
      <div className="amb-section">
        <button className="amb-button amb-button-primary" onClick={discoverFields} disabled={isDiscovering}>
          {isDiscovering ? t.discovering : t.discoverFields}
        </button>
        {discoveryError && <div className="amb-error">{discoveryError}</div>}
        {Object.keys(discoveredFields).length > 0 && (
          <div className="amb-fields">
            <label className="amb-label">{t.selectedFields} ({selectedCount}) <small>{t.dragHint}</small></label>
            <div className="amb-fields-grid" onDragOver={handleDragOver}>
              {orderedFields.map((key, index) => (
                <div
                  key={key}
                  draggable
                  onDragStart={(e) => handleDragStart(e, index)}
                  onDrop={(e) => handleDrop(e, index)}
                  className={`amb-field-item ${draggedIndex === index ? 'dragging' : ''}`}
                >
                  <label className="amb-checkbox-label">
                    <input type="checkbox" checked={discoveredFields[key]?.selected || false} onChange={() => toggleFieldSelection(key)} className="amb-checkbox" />
                    <span className="amb-field-name">{key}</span>
                    <span className="amb-field-value" title={discoveredFields[key]?.value}>{discoveredFields[key]?.value.substring(0, 20)}{discoveredFields[key]?.value.length > 20 ? "..." : ""}</span>
                  </label>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
      {selectedCount > 0 && (
        <div className="amb-section">
          <div className="amb-setting">
            <label>{t.prefix}</label>
            <input type="text" value={markupPrefix} onChange={(e) => setMarkupPrefix(e.target.value)} placeholder="N√§it: [, (" className="amb-input" />
          </div>
          <div className="amb-setting">
            <label>{t.separator}</label>
            <select value={markupSeparator} onChange={(e) => setMarkupSeparator(e.target.value)} disabled={useLineBreak} className="amb-select">
              {SEPARATORS.map((sep) => <option key={sep.value} value={sep.value}>{sep.label}</option>)}
            </select>
          </div>
          <div className="amb-setting">
            <label className="amb-checkbox-label">
              <input type="checkbox" checked={useLineBreak} onChange={(e) => setUseLineBreak(e.target.checked)} className="amb-checkbox" />
              <span>{t.useLineBreak}</span>
            </label>
          </div>
          <button className="amb-button amb-button-success" onClick={applyMarkup} disabled={isApplying || selectedCount === 0}>
            {isApplying ? t.applying : t.applyMarkup}
          </button>
        </div>
      )}
      {markupResults.length > 0 && (
        <div className="amb-section">
          <div className="amb-results-header">
            <h3>{t.results}</h3>
            <button className="amb-button amb-button-secondary" onClick={condenseAndCopy}>{t.condenseResults}</button>
          </div>
          <div className="amb-results-list">
            {markupResults.map((result, idx) => (
              <div key={idx} className="amb-result-item">
                <span className="amb-result-text">{result.text}</span>
                <span className="amb-result-count">√ó {result.count}</span>
              </div>
            ))}
          </div>
        </div>
      )}
      {successMessage && <div className="amb-success">{successMessage}</div>}
    </div>
  );
}
